<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Amelia Avatar</title>
    <style>
        body { margin: 0; background-color: #222; overflow: hidden; font-family: Arial; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #error { position: absolute; top: 10px; left: 10px; color: white; background: red; padding: 10px; }
    </style>
    <!-- Import map for ES modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="error" style="display:none;"></div>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from 'https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.4.2/lib/three-vrm.module.js';

        let currentVrm = null;
        let audioContext, analyser, lipsyncNode;
        let isTalking = false;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 20);
        camera.position.set(0, 1.4, 1.0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        const frontLight = new THREE.DirectionalLight(0xffffff, 1.0);
        frontLight.position.set(0, 1, 1);
        scene.add(frontLight);

        const errorDiv = document.getElementById('error');
        function showError(msg) {
            errorDiv.textContent = msg;
            errorDiv.style.display = 'block';
            console.error(msg);
        }

        // Load VRM
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        loader.load(
            'https://raw.githubusercontent.com/Evan-Milliken/my-avatar-repo/main/Amelia.vrm',
            async (gltf) => {
                try {
                    const vrm = gltf.userData.vrm;
                    VRMUtils.rotateVRM0(gltf); // Fix VRM0 orientation if needed
                    scene.add(vrm.scene);
                    currentVrm = vrm;
                    console.log("Amelia Loaded!");
                    initLipSync();
                } catch (e) {
                    showError('VRM process error: ' + e.message);
                }
            },
            (progress) => {
                console.log('Loading...', Math.round(100 * progress.loaded / progress.total) + '%');
            },
            (error) => showError('Load error (CORS?): ' + error.message)
        );

        // Lip sync setup (same as before)
        function initLipSync() {
            if (!currentVrm) return;
            audioContext = new AudioContext();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            lipsyncNode = audioContext.createScriptProcessor(2048, 1, 1);
            lipsyncNode.onaudioprocess = () => {
                analyser.getByteFrequencyData(dataArray);
                const volume = dataArray.reduce((a, b) => a + b) / dataArray.length / 255;
                if (isTalking && currentVrm) {
                    const aa = Math.max(0, volume * 2);
                    currentVrm.expressionManager.setValue('aa', aa);
                    currentVrm.expressionManager.setValue('o', aa * 0.5);
                }
            };
            lipsyncNode.connect(audioContext.destination);
        }

        window.startTalking = async (groqText, groqAudioUrl) => {
            if (!audioContext) audioContext = new AudioContext();
            isTalking = true;
            try {
                const res = await fetch(groqAudioUrl);
                const buffer = await res.arrayBuffer();
                const decoded = await audioContext.decodeAudioData(buffer);
                const source = audioContext.createBufferSource();
                source.buffer = decoded;
                source.connect(analyser);
                analyser.connect(lipsyncNode);
                source.start();
                source.onended = () => {
                    isTalking = false;
                    if (currentVrm) {
                        currentVrm.expressionManager.setValue('aa', 0);
                        currentVrm.expressionManager.setValue('o', 0);
                    }
                };
            } catch (e) {
                showError('Audio error: ' + e.message);
            }
            console.log('Talking:', groqText);
        };

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            controls.update();
            if (currentVrm) {
                // Blink
                const blinkValue = Math.max(0, Math.sin(Date.now() * 0.001) * 1.5 - 1.3);
                currentVrm.expressionManager.setValue('blink', blinkValue);
                // Eye gaze
                currentVrm.expressionManager.setValue('looking_left', Math.sin(Date.now() * 0.002) * 0.3);
                currentVrm.expressionManager.setValue('looking_right', Math.cos(Date.now() * 0.002) * 0.3);
                currentVrm.update(delta);
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
